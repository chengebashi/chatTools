# 聊天室

#### 客户端0:

##### 退出请求：{"login" = 0，"args":"exit"}

#### 服务端0：

##### 退出响应：不响应，直接关闭该用户的套接字



#### 客户端：

##### 登录请求：{“login” = 1,"args":{"user_name":"账号""password":"密码"}}

#### 服务端1：

##### 登录响应：{"login" = 1,"return" = 0   }  #登录成功返回0，用户名不存在返回1，密码错误返回2



#### 客户端2：

##### 注册请求：{"login" = 2,"args":{"nick_name":"用户名""user_name":"账号"，"password":"密码"，“phone”:"手机号"，“email”："邮箱"}}

#### 服务端2：

##### 注册响应：{"login":2，"return" = 0}      #注册成功返回0，用户名已存在返回1，账号已存在返回2，邮箱存在返回3



#### 客户端3：

##### 修改密码请求：{"login" = 3，"args":{"user_name":"账号"，"old_password":"旧密码"，"new_password":“新密码”}

#### 服务端3：

##### 修改密码响应：{"login":3，"return" = 0}    #修改成功返回0，账号不存在返回1，旧密码错误返回2



#### 客户端4：

##### 重置密码请求：{"login" = 4，"args":{"email":"邮箱账号"}}

#### 服务端4：

##### 重置密码响应：{"login"= 4,"return" = 0 }     #重置密码成功返回0，邮箱不存在返回1



## 服务端转发：

每当用户上线时，转发一条消息给所有客户端，某某用户已上线，并且发送一份在线用户名单，供客户端实现后续功能，

每当用户下线时，转发一条消息给所有客户端，某某用户已下线，并且发送一份在线用户名单，供客户端实现后续功能，



## 本项目中重点介绍单人聊天

#### 服务器的工作内容：

当发送方发送一条消息{"person_talk":"othername"(接收方名字)，"oneTOone_news":"聊天消息"}，服务器根据立马根据othername找出该用户名所对应的套接字，并且更改数据包{"person_talk":"nickname"(发送方名字)，"oneTOone_news":"聊天消息"}后将其发送到接收方那里。

### 客户端处理：

发送方：点击接收方的用户名，弹出一个窗口，输入聊天信息，点击发送，此时，服务器接到消息并转发，当接收方接到消息后，分析发现是私聊消息，开始弹出一个窗口，与发送方建立一条双向通道进行通信。

接收方：接到消息自动开启了一个窗口，那么就可以根据这个窗口跟发送方聊天。建立双向通道后再无发送方和接收方之分。

### （重点）双向通道怎么实现的呢？其中要处理那些问题呢？解决这其中的问题我想了一天其中没有查阅百度，也没有使用算法。

先谈论单人聊天(一对一，一对多，多对多)所遇到的问题：

**问题1**：

1v1窗口模块只有一个，如果1v1聊天刚好足够使用，如果1v3该怎么办呢，每次调用这个窗口都要用到窗口中的发送按钮，但是窗口类只有一个，当你和3个人聊天时，你每次点击发送按钮，就会发生混乱。当然有人会说，为每个用户单独创建一个类，供它一个人调用，但是此时这个类怎么绑定到你想与它聊天的那个人身上呢？这又成了个问题。

**问题2**：

如果解决了第一个问题后

当你点击张三的名字后，会弹出一个窗口，表示你正要与这个人聊天，那么如果此时你再点击这个人的姓名，就会重新再弹出一个窗口，此时有两个窗口，都是与张三在聊天，而张三那边也会弹出两个窗口，此时两人聊天无法同步，发生混乱



### 既然有问题，那么就有解决的方法，这是我个人的方法，不是很先进，但是勉强解决了问题。

主要是对列表的使用。假设当前在线人数为5个人，服务器会用列表的形式将这5个人的用户名发送过来

举个例子当前在线人数[“王一”，"刘二"，"张三"，"李四"，"宋五"]五个人在线。单人窗口类名为Myperson

这五个人的用户名其实就是五个按钮，点击谁就与谁聊天。那么我可以用每个人的用户名实例化5个对象，为5个人分配5个单独的聊天窗口，将每个人隔离开来。

user1 = Myperson()，user2 = Myperson()，user3 = Myperson()，user4 = Myperson()，user5 = Myperson()

建立一个列表dyname_win = []，这个列表是全局变量，动态的。然会为每个人添加对象

dyname_win.append([user1，“王一”，0])

dyname_win.append([user2，"刘二"，0])

dyname_win.append([user3，"张三"，0])

dyname_win.append([user4，"李四"，0])

dyname_win.append([user5，"宋五"，0'])

此时列表变成了[  [user1，“王一”，0] ，[user2，"刘二"，0]，......... ]，每个列表中都有3个动态元素，第一个是实例化窗口的对象，第二个是表示窗口的状态 0 / 1，0表示窗口关着的，1表示窗口开着的，第三个为空，用来存放在线用户名的。假设有5个人上线，服务器那边发过来了五个人的名单。客户端接收后，动态添加到此列表中，变成了这一样：

dyname_win.append([user1,，'王一'，0])

dyname_win.append([user2，'刘二'， 0])

dyname_win.append([user3，'张三'， 0])

dyname_win.append([user4，'李四'， 0])

dyname_win.append([user5，'宋五'， 0])

#### 现在来真实模拟单人聊天：

王一：我跟**宋五**聊天，我点击宋五的名字，此时系统会查询dyname_win列表找出数据**[user5，'宋五'，0]**,然后根据第一个数据user5，这是一个窗口对象，打开这个窗口与王一进行同步通话，并且，将0改为1，表示窗口已经被打开，建立通道，然后输入一条短信   '**你好，我叫王一**'， 点击发送按钮发送到服务器，然后服务器接到消息：**{"person_talk":"宋五"(接收方名字)，"oneTOone_news":"你好，我叫王一"}** 转发给宋五：**{"person_talk":"王一"(发送方名字)，"oneTOone_news":"你好，我叫王一"}**

宋五：接到消息**{"person_talk":"王一"(发送方名字)，"oneTOone_news":"你好，我叫王一"}**，提取person_talk得到名字：**王一**，然后查询dyname_win列表找出数据**[user1，'王一'，0],**然后根据第一个数据user1，这是一个窗口对象，打开这个窗口与王一进行同步通话，并且，将0改为1，表示窗口已经被打开，如果在通话过程中两个人有人关闭了窗口，此时1将被改为0。

依次类推，1对1，1对多聊天将毫无压力，并且消息与目标都已经同步。





## 文件传输协议

### 文件传输协议分为群文件和单人文件传输。



#### 1. 群文件传输：

#### 客户端请求：

###### 上传文件(文件夹){"up_files":"everyone","files_information":{"files_name":"文件名"，"files_size":"文件大小"，"files_md5":"文件md5值"}"}

###### 上传空文件夹：{"up_files":"everyone","dirs_information":{”dirs_name“:"文件夹名"，"dirs_size":"-1" }}

#### 服务端响应：

###### 上传文件响应：{"up_files":everyone,"return": 0, 1}   #校验md5无误即上传成功返回0， #md5校验不通过返回1

###### 上传文件夹则验证其中每一个文件





### 2.单人文件传输

#### 发送方

###### 上传文件（文件夹）：{"up_files":"my_nmae"，"files_information":{"files_name":"文件名"，"files_size":"文件大小"，"files_md5":"文件md5值"}"}

###### 上传空文件夹：{"up_files":"my_name"，”dirs_information":{”dirs_name“:"文件夹名"，"dirs_size":"-1" }“}

#### 服务器

##### 接收文件文件夹：接收文件后单独保存在一个文件夹内，并向接收方发送一个通知，通知有人向他发送了文件(夹)。

#### 接收方

##### 下载文件：接到服务端的通知后，选择接收或者拒绝，拒绝后不可重新下载，接收后则开始下载，并且关闭提示窗口，下载成功后会有提示。

